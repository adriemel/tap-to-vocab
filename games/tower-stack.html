<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tower Stack – Tap-to-Vocab</title>
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <style>
    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      border-radius: 12px;
      border: 2px solid #2a3a80;
      background: #080c18;
      max-width: 100%;
      touch-action: none;
    }
    .game-hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 400px;
      align-items: center;
    }
    .game-score {
      font-size: 1.4rem;
      font-weight: 800;
      color: var(--warn);
    }
    .game-plays {
      font-size: 0.9rem;
      color: var(--muted);
    }
    .game-overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(11,16,32,0.88);
      border-radius: 12px;
      gap: 16px;
      z-index: 10;
    }
    .game-overlay h2 {
      color: var(--ink);
      font-size: 1.8rem;
      margin: 0;
    }
    .game-overlay .final-score {
      font-size: 3rem;
      font-weight: 800;
      color: var(--warn);
    }
    .canvas-container {
      position: relative;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Tower Stack</h1>
      <div class="game-wrapper">
        <div class="game-hud">
          <span class="game-score" id="score-display">Score: 0</span>
          <span class="game-plays" id="plays-display"></span>
        </div>
        <div class="canvas-container" id="canvas-container">
          <canvas id="game-canvas" width="400" height="600"></canvas>
          <div class="game-overlay" id="overlay-start">
            <h2>Tower Stack</h2>
            <p style="color:var(--muted);text-align:center;margin:0;">Tap or click to drop blocks.<br>Stack them as high as you can!</p>
            <button class="btn" id="btn-start">Start Game</button>
          </div>
          <div class="game-overlay" id="overlay-end" style="display:none;">
            <h2>Game Over</h2>
            <div class="final-score" id="final-score">0</div>
            <p style="color:var(--muted);margin:0;" id="end-message"></p>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;">
              <button class="btn" id="btn-again" style="display:none;">Play Again</button>
              <button class="btn secondary" id="btn-done">Done</button>
            </div>
          </div>
        </div>
        <div class="controls">
          <button class="btn secondary" id="btn-cancel">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function () {
    var canvas = document.getElementById("game-canvas");
    var ctx = canvas.getContext("2d");
    var W = canvas.width;
    var H = canvas.height;

    // Session play tracking
    var MAX_PLAYS = 4;
    var playsKey = "game_plays_remaining";
    if (sessionStorage.getItem(playsKey) === null) {
      sessionStorage.setItem(playsKey, String(MAX_PLAYS));
    }
    var playsRemaining = parseInt(sessionStorage.getItem(playsKey), 10);

    var scoreDisplay = document.getElementById("score-display");
    var playsDisplay = document.getElementById("plays-display");
    var overlayStart = document.getElementById("overlay-start");
    var overlayEnd = document.getElementById("overlay-end");
    var finalScoreEl = document.getElementById("final-score");
    var endMessage = document.getElementById("end-message");
    var btnStart = document.getElementById("btn-start");
    var btnAgain = document.getElementById("btn-again");
    var btnDone = document.getElementById("btn-done");
    var btnCancel = document.getElementById("btn-cancel");

    function updatePlaysDisplay() {
      playsDisplay.textContent = "Plays left: " + playsRemaining;
    }
    updatePlaysDisplay();

    // ========== 3D Isometric Projection ==========
    // Blocks are stored as {x, z, w, d} in world coords (x=left-right, z=depth)
    // y (height) is implied by block index
    var BLOCK_H = 22;       // visual height of each block
    var BLOCK_DEPTH = 80;   // depth of blocks in world units
    var ISO_X = 0.7;        // isometric x scale
    var ISO_Z = 0.4;        // isometric z scale (depth → screen offset)

    // Project world (wx, wy, wz) to screen (sx, sy)
    // wy = stack height (0 = ground)
    function project(wx, wy, wz) {
      var sx = W / 2 + (wx * ISO_X) + (wz * ISO_Z * 0.5);
      var sy = H * 0.75 - wy + (wz * ISO_Z * 0.35);
      return { x: sx, y: sy };
    }

    // ========== Game State ==========
    var blocks = [];         // {x, z, w, d} in world space
    var currentBlock = null; // moving block
    var fallingPiece = null; // overhang that falls off
    var score = 0;
    var gameRunning = false;
    var animFrame = null;
    var cameraY = 0;         // current camera offset
    var targetCameraY = 0;   // target camera offset
    var BASE_SPEED = 1.8;
    var speed = BASE_SPEED;
    var direction = 1;
    var moveAxis = "x";      // alternates x/z each block
    var perfectCount = 0;    // consecutive perfect placements

    function blockColor(index) {
      var hue = (index * 22 + 10) % 360;
      return { h: hue, s: 65, l: 52 };
    }

    function hsl(h, s, l) {
      return "hsl(" + h + "," + s + "%," + l + "%)";
    }

    // ========== Draw a 3D isometric box ==========
    function drawBlock(wx, wz, ww, wd, wy, colorIdx, alpha) {
      var c = blockColor(colorIdx);
      var a = alpha !== undefined ? alpha : 1;

      // 4 corners of the top face in world space
      var tl = project(wx, wy, wz);
      var tr = project(wx + ww, wy, wz);
      var br = project(wx + ww, wy, wz + wd);
      var bl = project(wx, wy, wz + wd);

      // 4 corners of the bottom face
      var btl = project(wx, wy - BLOCK_H, wz);
      var btr = project(wx + ww, wy - BLOCK_H, wz);
      var bbr = project(wx + ww, wy - BLOCK_H, wz + wd);
      var bbl = project(wx, wy - BLOCK_H, wz + wd);

      ctx.globalAlpha = a;

      // Right face (darker)
      ctx.fillStyle = hsl(c.h, c.s, c.l - 15);
      ctx.beginPath();
      ctx.moveTo(tr.x, tr.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bbr.x, bbr.y);
      ctx.lineTo(btr.x, btr.y);
      ctx.closePath();
      ctx.fill();

      // Front face (medium)
      ctx.fillStyle = hsl(c.h, c.s, c.l - 8);
      ctx.beginPath();
      ctx.moveTo(bl.x, bl.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bbr.x, bbr.y);
      ctx.lineTo(bbl.x, bbl.y);
      ctx.closePath();
      ctx.fill();

      // Top face (bright)
      ctx.fillStyle = hsl(c.h, c.s, c.l + 8);
      ctx.beginPath();
      ctx.moveTo(tl.x, tl.y);
      ctx.lineTo(tr.x, tr.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bl.x, bl.y);
      ctx.closePath();
      ctx.fill();

      // Edge outlines
      ctx.strokeStyle = hsl(c.h, c.s, c.l + 18);
      ctx.lineWidth = 1;
      ctx.globalAlpha = a * 0.5;
      // Top face outline
      ctx.beginPath();
      ctx.moveTo(tl.x, tl.y);
      ctx.lineTo(tr.x, tr.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bl.x, bl.y);
      ctx.closePath();
      ctx.stroke();

      ctx.globalAlpha = 1;
    }

    // ========== Init / Spawn ==========
    function initGame() {
      blocks = [];
      score = 0;
      cameraY = 0;
      targetCameraY = 0;
      speed = BASE_SPEED;
      direction = 1;
      moveAxis = "x";
      perfectCount = 0;
      fallingPiece = null;
      scoreDisplay.textContent = "Score: 0";

      // Base block centered at origin
      blocks.push({ x: -60, z: -40, w: 120, d: BLOCK_DEPTH });

      spawnBlock();
      gameRunning = true;
      loop();
    }

    function spawnBlock() {
      var last = blocks[blocks.length - 1];
      if (moveAxis === "x") {
        currentBlock = { x: -180, z: last.z, w: last.w, d: last.d };
      } else {
        currentBlock = { x: last.x, z: -160, w: last.w, d: last.d };
      }
    }

    // ========== Drop Logic ==========
    function dropBlock() {
      if (!currentBlock || !gameRunning) return;
      var last = blocks[blocks.length - 1];
      var cur = currentBlock;

      var overlapX1 = Math.max(cur.x, last.x);
      var overlapX2 = Math.min(cur.x + cur.w, last.x + last.w);
      var overlapZ1 = Math.max(cur.z, last.z);
      var overlapZ2 = Math.min(cur.z + cur.d, last.z + last.d);
      var ow = overlapX2 - overlapX1;
      var od = overlapZ2 - overlapZ1;

      if (ow <= 0 || od <= 0) {
        // Complete miss — animate falling block
        fallingPiece = {
          x: cur.x, z: cur.z, w: cur.w, d: cur.d,
          wy: blocks.length * BLOCK_H,
          vy: 0, alpha: 1, colorIdx: blocks.length
        };
        currentBlock = null;
        gameOver();
        return;
      }

      // Check for perfect placement (within 3 units tolerance)
      var isPerfect = false;
      if (moveAxis === "x") {
        isPerfect = Math.abs(cur.x - last.x) < 3;
      } else {
        isPerfect = Math.abs(cur.z - last.z) < 3;
      }

      if (isPerfect) {
        // Snap perfectly
        perfectCount++;
        blocks.push({ x: last.x, z: last.z, w: last.w, d: last.d });
      } else {
        perfectCount = 0;
        // Create overhang falling piece
        if (moveAxis === "x") {
          var cutSide = cur.x < last.x ? "left" : "right";
          if (cutSide === "left") {
            fallingPiece = {
              x: cur.x, z: overlapZ1, w: overlapX1 - cur.x, d: od,
              wy: blocks.length * BLOCK_H, vy: 0, alpha: 1, colorIdx: blocks.length
            };
          } else {
            fallingPiece = {
              x: overlapX2, z: overlapZ1, w: (cur.x + cur.w) - overlapX2, d: od,
              wy: blocks.length * BLOCK_H, vy: 0, alpha: 1, colorIdx: blocks.length
            };
          }
        } else {
          var cutSideZ = cur.z < last.z ? "back" : "front";
          if (cutSideZ === "back") {
            fallingPiece = {
              x: overlapX1, z: cur.z, w: ow, d: overlapZ1 - cur.z,
              wy: blocks.length * BLOCK_H, vy: 0, alpha: 1, colorIdx: blocks.length
            };
          } else {
            fallingPiece = {
              x: overlapX1, z: overlapZ2, w: ow, d: (cur.z + cur.d) - overlapZ2,
              wy: blocks.length * BLOCK_H, vy: 0, alpha: 1, colorIdx: blocks.length
            };
          }
        }
        blocks.push({ x: overlapX1, z: overlapZ1, w: ow, d: od });
      }

      score++;
      scoreDisplay.textContent = "Score: " + score;

      // Increase speed every 5 blocks
      if (score % 5 === 0) {
        speed += 0.4;
      }

      // Smooth camera: raise target so top of tower stays centered
      targetCameraY = Math.max(0, blocks.length * BLOCK_H - H * 0.35);

      // Alternate axis
      moveAxis = moveAxis === "x" ? "z" : "x";
      spawnBlock();
    }

    function gameOver() {
      gameRunning = false;
      // Let the final draw/camera finish before showing overlay
      setTimeout(function () {
        if (animFrame) cancelAnimationFrame(animFrame);

        playsRemaining--;
        sessionStorage.setItem(playsKey, String(playsRemaining));
        updatePlaysDisplay();

        finalScoreEl.textContent = score;
        if (playsRemaining > 0) {
          btnAgain.style.display = "";
          endMessage.textContent = playsRemaining + " play" + (playsRemaining !== 1 ? "s" : "") + " remaining";
        } else {
          btnAgain.style.display = "none";
          endMessage.textContent = "No plays remaining. Great job!";
        }
        overlayEnd.style.display = "flex";
      }, 600);
    }

    // ========== Rendering ==========
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Starfield background
      ctx.fillStyle = "#080c18";
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(0, cameraY);

      // Draw ground shadow
      var g1 = project(-100, 0, -60);
      var g2 = project(100, 0, -60);
      var g3 = project(100, 0, 100);
      var g4 = project(-100, 0, 100);
      ctx.fillStyle = "rgba(30, 40, 80, 0.3)";
      ctx.beginPath();
      ctx.moveTo(g1.x, g1.y);
      ctx.lineTo(g2.x, g2.y);
      ctx.lineTo(g3.x, g3.y);
      ctx.lineTo(g4.x, g4.y);
      ctx.closePath();
      ctx.fill();

      // Draw stacked blocks from bottom to top
      for (var i = 0; i < blocks.length; i++) {
        var b = blocks[i];
        var wy = (i + 1) * BLOCK_H;
        drawBlock(b.x, b.z, b.w, b.d, wy, i);
      }

      // Draw falling overhang piece
      if (fallingPiece) {
        drawBlock(
          fallingPiece.x, fallingPiece.z,
          fallingPiece.w, fallingPiece.d,
          fallingPiece.wy,
          fallingPiece.colorIdx,
          fallingPiece.alpha
        );
      }

      // Draw current moving block
      if (currentBlock) {
        var c = currentBlock;
        var wy = (blocks.length + 1) * BLOCK_H;
        drawBlock(c.x, c.z, c.w, c.d, wy, blocks.length);
      }

      ctx.restore();
    }

    function loop() {
      // Smooth camera lerp
      cameraY += (targetCameraY - cameraY) * 0.08;

      // Move current block
      if (currentBlock && gameRunning) {
        if (moveAxis === "x") {
          currentBlock.x += speed * direction;
          if (currentBlock.x + currentBlock.w > 160) {
            currentBlock.x = 160 - currentBlock.w;
            direction = -1;
          }
          if (currentBlock.x < -160) {
            currentBlock.x = -160;
            direction = 1;
          }
        } else {
          currentBlock.z += speed * direction;
          if (currentBlock.z + currentBlock.d > 140) {
            currentBlock.z = 140 - currentBlock.d;
            direction = -1;
          }
          if (currentBlock.z < -140) {
            currentBlock.z = -140;
            direction = 1;
          }
        }
      }

      // Animate falling piece
      if (fallingPiece) {
        fallingPiece.vy += 0.8;
        fallingPiece.wy -= fallingPiece.vy;
        fallingPiece.alpha -= 0.02;
        if (fallingPiece.alpha <= 0) {
          fallingPiece = null;
        }
      }

      draw();
      animFrame = requestAnimationFrame(loop);
    }

    // ========== Controls ==========
    btnStart.onclick = function () {
      if (playsRemaining <= 0) {
        location.href = "/";
        return;
      }
      overlayStart.style.display = "none";
      overlayEnd.style.display = "none";
      initGame();
    };

    btnAgain.onclick = function () {
      overlayEnd.style.display = "none";
      initGame();
    };

    btnDone.onclick = function () {
      location.href = "/";
    };

    btnCancel.onclick = function () {
      gameRunning = false;
      if (animFrame) cancelAnimationFrame(animFrame);
      location.href = "/";
    };

    // Tap/click to drop
    canvas.addEventListener("pointerdown", function (e) {
      e.preventDefault();
      if (gameRunning) dropBlock();
    });

    // Keyboard
    document.addEventListener("keydown", function (e) {
      if (e.code === "Space" || e.key === " ") {
        e.preventDefault();
        if (gameRunning) dropBlock();
      }
    });

    // Responsive canvas sizing
    function resizeCanvas() {
      var container = document.getElementById("canvas-container");
      var maxW = Math.min(400, container.parentElement.clientWidth);
      canvas.style.width = maxW + "px";
      canvas.style.height = (maxW * 1.5) + "px";
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // Initial draw
    draw();
  })();
  </script>
</body>
</html>
